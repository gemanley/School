<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
		<title></title>
	</head>

	<body bgcolor="white">
				<table width="600">
			<tr>
				<td width="300"><tt>always @(posedge clock) begin</tt></td>
				<td width="300"><tt>always @(posedge clock) begin</tt></td>
			</tr>
			<tr>
				<td width="300"><tt>&nbsp;&nbsp;&nbsp;state1 = newstate1;</tt></td>
				<td width="300"><tt>&nbsp;&nbsp;&nbsp;state2 = newstate2;</tt></td>
			</tr>
			<tr>
				<td width="300"><tt>#10 newstate1 = func(state1, in1);</tt></td>
				<td width="300"><tt>#11 newstate2 = func(state2, in2);</tt></td>
			</tr>
			<tr>
				<td width="300"><tt>end</tt></td>
				<td width="300"><tt>end</tt></td>
			</tr>
		</table>
		<p>&lt;/&gt;</p>
		<table width="600">
			<tr>
				<td>In this example, each always block is a separate process. Both begin at the same instant of simulated time, namely when the clock rises. However, it <i>is not specified which one will begin first</i>. What is guaranteed is that both state1 and state2 will have their new values before simulation proceeds past the time instant of the rising clock edge. It is also guaranteed that the two assignments to newstate1 and newstate2 will be executed at different time instants. If we call the clock edge tr, then newstate1 will be assigned at tr+10 and newstate2 will be assigned at tr+11. Thus, there is no guaranteed ordering in the first part of these two processes, but there is a guaranteed ordering in the second part.
					<p>Graphically, the event ordering looks like this:</p>
					<p><img src="images/v0332g1.gif" height="196" width="224"></p>
					<p>Events 1 and 2 are unordered, while events 3 and 4 are ordered with respect to each other.</p>
					<p></p>
				</td>
			</tr>
		</table>
	</body>

</html>