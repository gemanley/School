<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
		<title></title>
	</head>

	<body bgcolor="white">
				<table width="600" cellpadding="10">
			<tr>
				<td>The assignment mechanics are pretty straightforward. The value of the right-hand side expression (<tt>rhs</tt>) is assigned to the left-hand side (<tt>lhs</tt>) register. Click each expression to learn about how it is evaluated.</td>
			</tr>
		</table>
		<p></p>
		<table width="600" border="1" cellpadding="5">
			<tr>
				<td>
					<table width="600">
						<tr>
							<td width="300" HALIGN="CENTER"><a href="b05084.htm"><tt>lhs = rhs;</tt></a></td>
							<td width="300" HALIGN="CENTER"><a href="c05084.htm"><tt>lhs[bit] = rhs;</tt></a></td>
						</tr>
						<tr>
							<td width="300" HALIGN="CENTER"><a href="d05084.htm"><tt>lhs[partmsb:partlsb] = rhs;</tt></a></td>
							<td width="300" HALIGN="CENTER"><a href="e05084.htm"><tt>{lhs1, lhs2} = rhs;</tt></a></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>There is only one complicating factor to this case. If the lhs has a different size than the rhs expression result, the appropriate value for the assignment must be determined. There are two cases:
					<p><tt>L(lhs) &gt; L(rhs)</tt><br>
					</p>
					<dl>
						<dd>The context of the rhs is the size of lhs, so this case can only happen if the rhs is self-determined. If the size of the rhs is smaller than the lhs, then the rhs value is zero-filled to the lhs size.
							<p></p>
					</dl>
					<tt>L(lhs) &lt; L(rhs)</tt><br>
					<dl>
						<dd>The rhs value is truncated on the left, so that as many of the low-order bits as are needed are put into the lhs.
					</dl>
				</td>
			</tr>
		</table>
	</body>

</html>